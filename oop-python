# Define a class called Dog
class Dog:
    # Constructor method to initialize object properties
    def __init__(self, name, breed):
        self.name = name  # instance variable for dog's name
        self.breed = breed  # instance variable for dog's breed

    # Method to make the dog bark
    def bark(self):
        return f"{self.name} says Woof!"

# Create an object (instance) of Dog
my_dog = Dog("Buddy", "Golden Retriever")

# Accessing method and properties
print(my_dog.name)       # Output: Buddy
print(my_dog.breed)      # Output: Golden Retriever
print(my_dog.bark())     # Output: Buddy says Woof!
# Parent class
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return f"{self.name} makes a sound"

# Child class inherits from Animal
class Cat(Animal):
    def speak(self):
        return f"{self.name} says Meow!"

# Create instances
generic_animal = Animal("Some Animal")
cat = Cat("Whiskers")

print(generic_animal.speak())  # Output: Some Animal makes a sound
print(cat.speak())             # Output: Whiskers says Meow!
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # private variable (name mangling)

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

    def get_balance(self):
        return self.__balance

# Create a bank account object
account = BankAccount("Lydia", 1000)

account.deposit(500)
print(account.get_balance())  # Output: 1500

account.withdraw(700)
print(account.get_balance())  # Output: 800

# Attempting to access private variable directly will fail
# print(account.__balance)  # class Bird:
    def fly(self):
        return "Some birds can fly"

class Parrot(Bird):
    def fly(self):
        return "Parrots can fly"

class Penguin(Bird):
    def fly(self):
        return "Penguins can't fly"

# Iterate over different bird types
birds = [Parrot(), Penguin(), Bird()]

for bird in birds:
    print(bird.fly())
# Define a class called Car
class Car:
    # Constructor method
    def __init__(self, brand, model):
        self.brand = brand   # instance variable for car's brand
        self.model = model   # instance variable for car's model

    # Method to start the car
    def start(self):
        return f"{self.brand} {self.model} engine started."

# Create an instance of Car
my_car = Car("Toyota", "Corolla")

# Access attributes and methods
print(my_car.brand)         # Output: Toyota
print(my_car.model)         # Output: Corolla
print(my_car.start())       # Output: Toyota Corolla engine started.

# Parent class
class Vehicle:
    def __init__(self, make):
        self.make = make

    def move(self):
        return f"{self.make} vehicle is moving."

# Child class inherits from Vehicle
class Bike(Vehicle):
    def move(self):
        return f"{self.make} bike is pedaled."

# Create instances
generic_vehicle = Vehicle("Generic")
bike = Bike("Giant")

print(generic_vehicle.move())  # Output: Generic vehicle is moving.
print(bike.move())             # Output: Giant bike is pedaled.

# Class demonstrating encapsulation
class Wallet:
    def __init__(self, owner, money):
        self.owner = owner
        self.__money = money  # private attribute

    def add_money(self, amount):
        if amount > 0:
            self.__money += amount

    def spend_money(self, amount):
        if 0 < amount <= self.__money:
            self.__money -= amount
            return True
        return False

    def check_balance(self):
        return self.__money

# Create Wallet instance
my_wallet = Wallet("Alice", 200)

my_wallet.add_money(50)
print(my_wallet.check_balance())  # Output: 250

my_wallet.spend_money(70)
print(my_wallet.check_balance())  # Output: 180

# Polymorphism with different Vehicle types
class Airplane(Vehicle):
    def move(self):
        return f"{self.make} airplane is flying."

vehicles = [Bike("Trek"), Airplane("Boeing"), Vehicle("Ford")]

for v in vehicles:
    print(v.move())

# Define a class named Animal
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
        
    def make_sound(self):
        print(f"{self.name} says: Hello!")

# Create instances (objects) of the Animal class
dog = Animal("Buddy", "Dog")
cat = Animal("Whiskers", "Cat")

# Call methods on the objects
dog.make_sound()  # Output: Buddy says: Hello!
cat.make_sound()  # Output: Whiskers says: Hello!
from abc import ABC, abstractmethod

# ------------------------------
# 1️⃣ CLASS & OBJECT, CONSTRUCTOR
# ------------------------------
class Person:
    def __init__(self, name: str, age: int):
        self.name = name              # Public attribute
        self._age = age               # Protected attribute (by convention)
        self.__secret = "hidden"      # Private attribute (name mangling)

    def greet(self):
        print(f"Hi, I'm {self.name} and I'm {self._age} years old.")

    def get_secret(self):
        return self.__secret          # Accessing private attribute via method


# ------------------------------
# 2️⃣ INHERITANCE
# ------------------------------
class Employee(Person):
    def __init__(self, name: str, age: int, job_title: str):
        super().__init__(name, age)   # Call parent constructor
        self.job_title = job_title

    def greet(self):  # POLYMORPHISM: overriding parent method
        print(f"Hello, I'm {self.name}, a {self.job_title}.")


# ------------------------------
# 3️⃣ ABSTRACTION (Abstract Base Class)
# ------------------------------
class Payable(ABC):
    @abstractmethod
    def calculate_salary(self) -> float:
        pass


# ------------------------------
# 4️⃣ MULTIPLE INHERITANCE + POLYMORPHISM
# ------------------------------
class Manager(Employee, Payable):
    def __init__(self, name: str, age: int, job_title: str, base_salary: float, bonus: float):
        super().__init__(name, age, job_title)
        self.base_salary = base_salary
        self.bonus = bonus

    def calculate_salary(self) -> float:
        return self.base_salary + self.bonus

    def greet(self):
        # Extending the overridden method
        super().greet()
        print("I manage the team and handle projects.")


# ------------------------------
# 5️⃣ ENCAPSULATION via Getters/Setters
# ------------------------------
class BankAccount:
    def __init__(self, owner: str, balance: float = 0.0):
        self.owner = owner
        self.__balance = balance   # Private variable

    def deposit(self, amount: float):
        if amount > 0:
            self.__balance += amount
        else:
            print("Invalid deposit amount!")

    def withdraw(self, amount: float):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
        else:
            print("Insufficient funds or invalid amount!")

    def get_balance(self):
        return self.__balance


# ------------------------------
# 6️⃣ USAGE EXAMPLES
# ------------------------------
if __name__ == "__main__":
    # Person
    p = Person("Alice", 25)
    p.greet()
    print("Secret:", p.get_secret())
    print()

    # Employee
    e = Employee("Bob", 30, "Developer")
    e.greet()
    print()

    # Manager with abstract method implemented
    m = Manager("Carol", 40, "Project Manager", base_salary=5000, bonus=1000)
    m.greet()
    print("Manager Salary:", m.calculate_salary())
    print()

    # BankAccount
    account = BankAccount("Dave", 1000)
    account.deposit(500)
    account.withdraw(200)
    print(f"{account.owner}'s Balance:", account.get_balance())

