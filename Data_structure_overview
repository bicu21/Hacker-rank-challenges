phonebook = {"Alice": "555-1234", "Bob": "555-5678"}
print(phonebook["Alice"])  # Output: 555-1234
point = (10, 4)
color = ('red', 255, 0, 0)
fruits = {"apple", "banana", "cherry"}
fruits.add("banana")  # No change, since "banana" is already present
stack = []
stack.append("a")   # Push onto stack
stack.append("b")
stack.pop()         # Removes and returns "b"
from collections import deque
queue = deque()
queue.append("a")     # Enqueue
queue.append("b")
queue.popleft()       # Dequeue: returns "a"
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Create the tree manually
root = Node(10)
root.left = Node(5)
root.right = Node(15)


root.left.left = Node(3)
root.left.right = Node(7)
def inorder_traversal(node):
    if node:
        inorder_traversal(node.left)
        print(node.data, end=" ")
        inorder_traversal(node.right)

inorder_traversal(root)  # Output: 3 5 7 10 15
from collections import deque

# Create a queue
queue = deque()

# Enqueue (Add elements)
queue.append('a')
queue.append('b')
queue.append('c')

print("Queue after enqueuing:", queue)

# Dequeue (Remove elements)
item = queue.popleft()
print("Dequeued item:", item)

print("Queue after dequeuing:", queue)
Queue after enqueuing: deque(['a', 'b', 'c'])
Dequeued item: a
Queue after dequeuing: deque(['b', 'c'])
# Create an empty stack
stack = []

# Push elements (add)
stack.append('x')
stack.append('y')
stack.append('z')

print("Stack after pushes:", stack)

# Pop elements (remove)
item = stack.pop()
print("Popped item:", item)

print("Stack after popping:", stack)
Stack after pushes: ['x', 'y', 'z']
Popped item: z
Stack after popping: ['x', 'y']
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:

    # Function to insert a node
    def insert(self, root, key):
        # Step 1 - Perform normal BST insertion
        if not root:
            return Node(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        # Step 2 - Update the height of the ancestor node
        root.height = 1 + max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance = self.getBalance(root)

        # Step 4 - Balance the tree

        # Case 1 - Left Left
        if balance > 1 and key < root.left.key:
            return self.rightRotate(root)

        # Case 2 - Right Right
        if balance < -1 and key > root.right.key:
            return self.leftRotate(root)

        # Case 3 - Left Right
        if balance > 1 and key > root.left.key:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)

        # Case 4 - Right Left
        if balance < -1 and key < root.right.key:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)

        return root

    # Recursive function to delete a node
    def delete(self, root, key):
        if not root:
            return root

        elif key < root.key:
            root.left = self.delete(root.left, key)

        elif key > root.key:
            root.right = self.delete(root.right, key)

        else:
            # node with only one child or no child
            if not root.left:
                return root.right
            elif not root.right:
                return root.left

            # node with two children: get the inorder successor
            temp = self.getMinValueNode(root.right)
            root.key = temp.key
            root.right = self.delete(root.right, temp.key)

        # If the tree has only one node
        if not root:
            return root

        # Update the height
        root.height = 1 + max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Check balance
        balance = self.getBalance(root)

        # Balance the tree
        # Left Left
        if balance > 1 and self.getBalance(root.left) >= 0:
            return self.rightRotate(root)

        # Left Right
        if balance > 1 and self.getBalance(root.left) < 0:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)

        # Right Right
        if balance < -1 and self.getBalance(root.right) <= 0:
            return self.leftRotate(root)

        # Right Left
        if balance < -1 and self.getBalance(root.right) > 0:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)

        return root

    def leftRotate(self, z):
        y = z.right
        T2 = y.left

        # Perform rotation
        y.left = z
        z.right = T2

        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return new root
        return y

    def rightRotate(self, z):
        y = z.left
        T3 = y.right

        # Perform rotation
        y.right = z
        z.left = T3

        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return new root
        return y

    def getHeight(self, node):
        if not node:
            return 0
        return node.height

    def getBalance(self, node):
        if not node:
            return 0
        return self.getHeight(node.left) - self.getHeight(node.right)

    def getMinValueNode(self, node):
        if node is None or node.left is None:
            return node
        return self.getMinValueNode(node.left)

    def preOrder(self, root):
        if not root:
            return
        print("{0} ".format(root.key), end="")
        self.preOrder(root.left)
        self.preOrder(root.right)

    def inOrder(self, root):
        if not root:
            return
        self.inOrder(root.left)
        print("{0} ".format(root.key), end="")
        self.inOrder(root.right)


# Driver code
if __name__ == "__main__":
    tree = AVLTree()
    root = None

    nums = [10, 20, 30, 40, 50, 25]

    for num in nums:
        root = tree.insert(root, num)

    print("Preorder traversal after insertion:")
    tree.preOrder(root)
    print("\nInorder traversal after insertion:")
    tree.inOrder(root)

    key_to_delete = 40
    print(f"\n\nDeleting node {key_to_delete}")
    root = tree.delete(root, key_to_delete)

    print("Preorder traversal after deletion:")
    tree.preOrder(root)
    print("\nInorder traversal after deletion:")
    tree.inOrder(root)
import random

# Initialize an empty list
data = []

# Insert random numbers into the list
for _ in range(10):
    num = random.randint(1, 100)
    data.append(num)
print("List after insertions:", data)

# Randomly access elements
for _ in range(3):
    index = random.randint(0, len(data) - 1)
    print(f"Random access at index {index}: {data[index]}")

# Randomly remove elements
for _ in range(3):
    if data:  # Check if list is not empty
        index = random.randint(0, len(data) - 1)
        removed = data.pop(index)
        print(f"Removed element {removed} at index {index}")

print("Final list:", data)
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None

    def is_empty(self):
        return len(self.items) == 0

from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        return None

    def is_empty(self):
        return len(self.items) == 0
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        if not self.head:
            self.head = Node(data)
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = Node(data)

import sys
sys.setrecursionlimit(10**6)

class SegmentTree:
    def __init__(self, size):
        self.N = size
        self.tree = [0] * (4 * size)

    def build(self, pos, l, r, base_array):
        if l == r:
            self.tree[pos] = base_array[l]
            return
        mid = (l + r) // 2
        self.build(2*pos, l, mid, base_array)
        self.build(2*pos+1, mid+1, r, base_array)
        self.tree[pos] = max(self.tree[2*pos], self.tree[2*pos+1])

    def update(self, pos, l, r, idx, val):
        if l == r:
            self.tree[pos] = val
            return
        mid = (l + r) // 2
        if idx <= mid:
            self.update(2*pos, l, mid, idx, val)
        else:
            self.update(2*pos+1, mid+1, r, idx, val)
        self.tree[pos] = max(self.tree[2*pos], self.tree[2*pos+1])

    def query(self, pos, l, r, ql, qr):
        if ql > r or qr < l:
            return -float('inf')
        if ql <= l and r <= qr:
            return self.tree[pos]
        mid = (l + r) // 2
        return max(
            self.query(2*pos, l, mid, ql, qr),
            self.query(2*pos+1, mid+1, r, ql, qr)
        )

# Heavy-Light Decomposition
class HLD:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]
        self.parent = [-1]*n
        self.depth = [0]*n
        self.heavy = [-1]*n
        self.head = [0]*n
        self.pos = [0]*n
        self.curr_pos = 0
        self.base_array = [0]*n
        self.segment_tree = SegmentTree(n)
        self.edge_index = {}

    def add_edge(self, u, v, w, idx):
        self.adj[u].append((v, w))
        self.adj[v].append((u, w))
        self.edge_index[(u, v)] = idx
        self.edge_index[(v, u)] = idx

    def dfs(self, u, p):
        size = 1
        max_size = 0
        for v, w in self.adj[u]:
            if v != p:
                self.parent[v] = u
                self.depth[v] = self.depth[u] + 1
                subtree_size = self.dfs(v, u)
                if subtree_size > max_size:
                    max_size = subtree_size
                    self.heavy[u] = v
                size += subtree_size
        return size

    def decompose(self, u, h, weights):
        self.head[u] = h
        self.pos[u] = self.curr_pos
        self.base_array[self.curr_pos] = weights[u]
        self.curr_pos += 1
        if self.heavy[u] != -1:
            self.decompose(self.heavy[u], h, weights)
            for v, w in self.adj[u]:
                if v != self.parent[u] and v != self.heavy[u]:
                    self.decompose(v, v, weights)

    def build(self, weights):
        self.dfs(0, -1)
        self.decompose(0, 0, weights)
        self.segment_tree.build(1, 0, self.n - 1, self.base_array)

    def query(self, u, v):
        res = -float('inf')
        while self.head[u] != self.head[v]:
            if self.depth[self.head[u]] < self.depth[self.head[v]]:
                u, v = v, u
            res = max(res, self.segment_tree.query(1, 0, self.n - 1, self.pos[self.head[u]], self.pos[u]))
            u = self.parent[self.head[u]]
        if u == v:
            return res
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        res = max(res, self.segment_tree.query(1, 0, self.n - 1, self.pos[u]+1, self.pos[v]))
        return res

    def update(self, u, v, w):
        if self.depth[u] < self.depth[v]:
            u, v = v, u
        self.segment_tree.update(1, 0, self.n - 1, self.pos[u], w)


# -----------------------------
# 🌲 Example Tree and Usage
# -----------------------------
#        0
#       / \
#      1   2
#     / \
#    3   4

n = 5
edges = [
    (0, 1, 10),
    (0, 2, 5),
    (1, 3, 4),
    (1, 4, 6),
]

hld = HLD(n)
weights = [0] * n  # node-weight initialization

for idx, (u, v, w) in enumerate(edges):
    hld.add_edge(u, v, w, idx)
    weights[v] = w  # assuming weight is stored at child

hld.build(weights)

print("Max between 3 and 4:", hld.query(3, 4))  # Output: 6
hld.update(1, 4, 15)
print("After update, Max between 3 and 4:", hld.query(3, 4))  # Output: 15
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        curr = self.root
        for ch in word:
            curr = curr.children.setdefault(ch, TrieNode())
        curr.is_word = True

    def search(self, word):
        curr = self.root
        for ch in word:
            if ch not in curr.children:
                return False
            curr = curr.children[ch]
        return curr.is_word

trie = Trie()
trie.insert("apple")
print(trie.search("apple"))  # Output: True
print(trie.search("app"))    # Output: False
# -------------------------
# Stack Implementation
# -------------------------
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        return None

    def peek(self):
        return self.stack[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)


# -------------------------
# Queue Implementation
# -------------------------
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)


# -------------------------
# Linked List Implementation
# -------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        temp = self.head
        while temp.next:
            temp = temp.next
        temp.next = new_node

    def display(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -> ")
            temp = temp.next
        print("None")


# -------------------------
# Binary Search
# -------------------------
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1


# -------------------------
# Quick Sort
# -------------------------
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)


# -------------------------
# Example Usage
# -------------------------
if __name__ == "__main__":
    # Stack
    s = Stack()
    s.push(10)
    s.push(20)
    print("Stack pop:", s.pop())

    # Queue
    q = Queue()
    q.enqueue(1)
    q.enqueue(2)
    print("Queue dequeue:", q.dequeue())

    # Linked List
    ll = LinkedList()
    ll.append(5)
    ll.append(10)
    ll.display()

    # Binary Search
    arr = [1, 2, 3, 4, 5]
    print("Binary Search index of 4:", binary_search(arr, 4))

    # Quick Sort
    unsorted = [3, 6, 8, 10, 1, 2, 1]
    print("Quick Sort:", quick_sort(unsorted))
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid   # found the target at index mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # not found

# Example usage
numbers = [1, 3, 5, 7, 9, 11]
print(binary_search(numbers, 7))   # ➞ 3
print(binary_search(numbers, 4))   # ➞ -1
"""
dsa.py
A compact collection of common data structures and algorithms in Python
Run: python dsa.py
"""

from collections import deque, defaultdict
import heapq
from typing import List, Dict, Tuple, Optional, Any


# -----------------------------
# Searching & Sorting
# -----------------------------
def binary_search(arr: List[int], target: int) -> int:
    """Return index of target or -1. O(log n)"""
    lo, hi = 0, len(arr) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if arr[mid] == target:
            return mid
        if arr[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1


def mergesort(arr: List[int]) -> List[int]:
    """Stable sort. O(n log n)"""
    if len(arr) <= 1:
        return arr[:]
    mid = len(arr) // 2
    left = mergesort(arr[:mid])
    right = mergesort(arr[mid:])
    res = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i]); i += 1
        else:
            res.append(right[j]); j += 1
    res.extend(left[i:]); res.extend(right[j:])
    return res


def quicksort(arr: List[int]) -> List[int]:
    """Quicksort (not in-place). Average O(n log n), worst O(n^2)"""
    if len(arr) <= 1:
        return arr[:]
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    mid = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + mid + quicksort(right)


# -----------------------------
# Basic Data Structures
# -----------------------------
class Stack:
    def __init__(self):
        self._data = []
    def push(self, x): self._data.append(x)
    def pop(self):
        return self._data.pop() if self._data else None
    def peek(self):
        return self._data[-1] if self._data else None
    def is_empty(self): return len(self._data) == 0
    def __len__(self): return len(self._data)


class Queue:
    def __init__(self):
        self._dq = deque()
    def push(self, x): self._dq.append(x)
    def pop(self):
        return self._dq.popleft() if self._dq else None
    def is_empty(self): return len(self._dq) == 0
    def __len__(self): return len(self._dq)


class LinkedListNode:
    def __init__(self, val):
        self.val = val
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    def append(self, val):
        node = LinkedListNode(val)
        if not self.head:
            self.head = node
            return
        cur = self.head
        while cur.next:
            cur = cur.next
        cur.next = node
    def to_list(self):
        res = []
        cur = self.head
        while cur:
            res.append(cur.val); cur = cur.next
        return res


# -----------------------------
# Graph Algorithms
# -----------------------------
def bfs(graph: Dict[Any, List[Any]], start: Any) -> List[Any]:
    """Breadth-first traversal order. O(V+E)"""
    q = deque([start])
    seen = {start}
    order = []
    while q:
        node = q.popleft()
        order.append(node)
        for nei in graph.get(node, []):
            if nei not in seen:
                seen.add(nei)
                q.append(nei)
    return order


def dfs(graph: Dict[Any, List[Any]], start: Any) -> List[Any]:
    """Depth-first traversal order (iterative). O(V+E)"""
    stack = [start]
    seen = {start}
    order = []
    while stack:
        node = stack.pop()
        order.append(node)
        for nei in graph.get(node, [])[::-1]:
            if nei not in seen:
                seen.add(nei)
                stack.append(nei)
    return order


def topological_sort(graph: Dict[Any, List[Any]]) -> List[Any]:
    """Kahn's algorithm. Returns a topological order or empty list if cycle."""
    indeg = defaultdict(int)
    for u in graph:
        indeg[u]  # ensure key
        for v in graph[u]:
            indeg[v] += 1
    q = deque([u for u in indeg if indeg[u] == 0])
    order = []
    while q:
        u = q.popleft()
        order.append(u)
        for v in graph.get(u, []):
            indeg[v] -= 1
            if indeg[v] == 0:
                q.append(v)
    if len(order) != len(indeg):
        return []  # cycle
    return order


def dijkstra(graph: Dict[Any, List[Tuple[Any, int]]], src: Any) -> Dict[Any, int]:
    """Shortest distances from src in weighted graph with non-negative weights."""
    dist = {}
    pq = [(0, src)]
    while pq:
        d, u = heapq.heappop(pq)
        if u in dist:
            continue
        dist[u] = d
        for v, w in graph.get(u, []):
            if v not in dist:
                heapq.heappush(pq, (d + w, v))
    return dist


# -----------------------------
# Union-Find (Disjoint Set)
# -----------------------------
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    def union(self, x: int, y: int) -> bool:
        rx, ry = self.find(x), self.find(y)
        if rx == ry:
            return False
        if self.rank[rx] < self.rank[ry]:
            self.parent[rx] = ry
        elif self.rank[ry] < self.rank[rx]:
            self.parent[ry] = rx
        else:
            self.parent[ry] = rx
            self.rank[rx] += 1
        return True


# -----------------------------
# Heaps / Priority Queue helpers
# -----------------------------
class MinHeap:
    def __init__(self, iterable=None):
        self._h = []
        if iterable:
            for x in iterable:
                heapq.heappush(self._h, x)
    def push(self, x): heapq.heappush(self._h, x)
    def pop(self): return heapq.heappop(self._h) if self._h else None
    def peek(self): return self._h[0] if self._h else None
    def __len__(self): return len(self._h)


# -----------------------------
# Misc Algorithms
# -----------------------------
def two_sum(nums: List[int], target: int) -> Optional[Tuple[int,int]]:
    """Return indices of two numbers adding to target, or None. O(n)"""
    seen = {}
    for i, x in enumerate(nums):
        need = target - x
        if need in seen:
            return (seen[need], i)
        seen[x] = i
    return None


def longest_common_prefix(strs: List[str]) -> str:
    if not strs: return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# -----------------------------
# Examples / Basic tests
# -----------------------------
def _run_examples():
    print("=== Searching & Sorting ===")
    a = [1,2,3,4,5,8,13]
    print("binary_search 8 ->", binary_search(a, 8))
    arr = [5,2,9,1,5,6]
    print("mergesort ->", mergesort(arr))
    print("quicksort ->", quicksort(arr))

    print("\n=== Stack / Queue / LinkedList ===")
    s = Stack(); s.push(10); s.push(20)
    print("stack pop ->", s.pop())
    q = Queue(); q.push(1); q.push(2)
    print("queue pop ->", q.pop())
    ll = LinkedList(); ll.append(5); ll.append(7); ll.append(9)
    print("linkedlist ->", ll.to_list())

    print("\n=== Graph Traversals ===")
    g = {
        0: [1,2],
        1: [2],
        2: [0,3],
        3: [3]
    }
    print("bfs from 2 ->", bfs(g, 2))
    print("dfs from 2 ->", dfs(g, 2))

    print("\n=== Topo & Dijkstra ===")
    g2 = {'a':['b','c'], 'b':['d'], 'c':['d'], 'd':[]}
    print("topo ->", topological_sort(g2))
    wg = {
        'A': [('B',5), ('C',1)],
        'B': [('A',5), ('C',2), ('D',1)],
        'C': [('A',1), ('B',2), ('D',4), ('E',8)],
        'D': [('B',1), ('C',4), ('E',3)],
        'E': [('C',8), ('D',3)]
    }
    print("dijkstra from A ->", dijkstra(wg, 'A'))

    print("\n=== Union-Find ===")
    uf = UnionFind(5)
    uf.union(0,1); uf.union(1,2)
    print("find 2 ->", uf.find(2), "find 3 ->", uf.find(3))

    print("\n=== Heaps & Two-sum ===")
    h = MinHeap([3,1,4])
    print("minheap pop ->", h.pop())
    print("two_sum [2,7,11,15], 9 ->", two_sum([2,7,11,15], 9))

if __name__ == "__main__":
    _run_examples()




