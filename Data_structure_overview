phonebook = {"Alice": "555-1234", "Bob": "555-5678"}
print(phonebook["Alice"])  # Output: 555-1234
point = (10, 4)
color = ('red', 255, 0, 0)
fruits = {"apple", "banana", "cherry"}
fruits.add("banana")  # No change, since "banana" is already present
stack = []
stack.append("a")   # Push onto stack
stack.append("b")
stack.pop()         # Removes and returns "b"
from collections import deque
queue = deque()
queue.append("a")     # Enqueue
queue.append("b")
queue.popleft()       # Dequeue: returns "a"
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Create the tree manually
root = Node(10)
root.left = Node(5)
root.right = Node(15)


root.left.left = Node(3)
root.left.right = Node(7)
def inorder_traversal(node):
    if node:
        inorder_traversal(node.left)
        print(node.data, end=" ")
        inorder_traversal(node.right)

inorder_traversal(root)  # Output: 3 5 7 10 15
from collections import deque

# Create a queue
queue = deque()

# Enqueue (Add elements)
queue.append('a')
queue.append('b')
queue.append('c')

print("Queue after enqueuing:", queue)

# Dequeue (Remove elements)
item = queue.popleft()
print("Dequeued item:", item)

print("Queue after dequeuing:", queue)
Queue after enqueuing: deque(['a', 'b', 'c'])
Dequeued item: a
Queue after dequeuing: deque(['b', 'c'])
# Create an empty stack
stack = []

# Push elements (add)
stack.append('x')
stack.append('y')
stack.append('z')

print("Stack after pushes:", stack)

# Pop elements (remove)
item = stack.pop()
print("Popped item:", item)

print("Stack after popping:", stack)
Stack after pushes: ['x', 'y', 'z']
Popped item: z
Stack after popping: ['x', 'y']
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:

    # Function to insert a node
    def insert(self, root, key):
        # Step 1 - Perform normal BST insertion
        if not root:
            return Node(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        # Step 2 - Update the height of the ancestor node
        root.height = 1 + max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance = self.getBalance(root)

        # Step 4 - Balance the tree

        # Case 1 - Left Left
        if balance > 1 and key < root.left.key:
            return self.rightRotate(root)

        # Case 2 - Right Right
        if balance < -1 and key > root.right.key:
            return self.leftRotate(root)

        # Case 3 - Left Right
        if balance > 1 and key > root.left.key:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)

        # Case 4 - Right Left
        if balance < -1 and key < root.right.key:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)

        return root

    # Recursive function to delete a node
    def delete(self, root, key):
        if not root:
            return root

        elif key < root.key:
            root.left = self.delete(root.left, key)

        elif key > root.key:
            root.right = self.delete(root.right, key)

        else:
            # node with only one child or no child
            if not root.left:
                return root.right
            elif not root.right:
                return root.left

            # node with two children: get the inorder successor
            temp = self.getMinValueNode(root.right)
            root.key = temp.key
            root.right = self.delete(root.right, temp.key)

        # If the tree has only one node
        if not root:
            return root

        # Update the height
        root.height = 1 + max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Check balance
        balance = self.getBalance(root)

        # Balance the tree
        # Left Left
        if balance > 1 and self.getBalance(root.left) >= 0:
            return self.rightRotate(root)

        # Left Right
        if balance > 1 and self.getBalance(root.left) < 0:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)

        # Right Right
        if balance < -1 and self.getBalance(root.right) <= 0:
            return self.leftRotate(root)

        # Right Left
        if balance < -1 and self.getBalance(root.right) > 0:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)

        return root

    def leftRotate(self, z):
        y = z.right
        T2 = y.left

        # Perform rotation
        y.left = z
        z.right = T2

        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return new root
        return y

    def rightRotate(self, z):
        y = z.left
        T3 = y.right

        # Perform rotation
        y.right = z
        z.left = T3

        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return new root
        return y

    def getHeight(self, node):
        if not node:
            return 0
        return node.height

    def getBalance(self, node):
        if not node:
            return 0
        return self.getHeight(node.left) - self.getHeight(node.right)

    def getMinValueNode(self, node):
        if node is None or node.left is None:
            return node
        return self.getMinValueNode(node.left)

    def preOrder(self, root):
        if not root:
            return
        print("{0} ".format(root.key), end="")
        self.preOrder(root.left)
        self.preOrder(root.right)

    def inOrder(self, root):
        if not root:
            return
        self.inOrder(root.left)
        print("{0} ".format(root.key), end="")
        self.inOrder(root.right)


# Driver code
if __name__ == "__main__":
    tree = AVLTree()
    root = None

    nums = [10, 20, 30, 40, 50, 25]

    for num in nums:
        root = tree.insert(root, num)

    print("Preorder traversal after insertion:")
    tree.preOrder(root)
    print("\nInorder traversal after insertion:")
    tree.inOrder(root)

    key_to_delete = 40
    print(f"\n\nDeleting node {key_to_delete}")
    root = tree.delete(root, key_to_delete)

    print("Preorder traversal after deletion:")
    tree.preOrder(root)
    print("\nInorder traversal after deletion:")
    tree.inOrder(root)
import random

# Initialize an empty list
data = []

# Insert random numbers into the list
for _ in range(10):
    num = random.randint(1, 100)
    data.append(num)
print("List after insertions:", data)

# Randomly access elements
for _ in range(3):
    index = random.randint(0, len(data) - 1)
    print(f"Random access at index {index}: {data[index]}")

# Randomly remove elements
for _ in range(3):
    if data:  # Check if list is not empty
        index = random.randint(0, len(data) - 1)
        removed = data.pop(index)
        print(f"Removed element {removed} at index {index}")

print("Final list:", data)
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None

    def is_empty(self):
        return len(self.items) == 0

from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        return None

    def is_empty(self):
        return len(self.items) == 0
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        if not self.head:
            self.head = Node(data)
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = Node(data)

import sys
sys.setrecursionlimit(10**6)

class SegmentTree:
    def __init__(self, size):
        self.N = size
        self.tree = [0] * (4 * size)

    def build(self, pos, l, r, base_array):
        if l == r:
            self.tree[pos] = base_array[l]
            return
        mid = (l + r) // 2
        self.build(2*pos, l, mid, base_array)
        self.build(2*pos+1, mid+1, r, base_array)
        self.tree[pos] = max(self.tree[2*pos], self.tree[2*pos+1])

    def update(self, pos, l, r, idx, val):
        if l == r:
            self.tree[pos] = val
            return
        mid = (l + r) // 2
        if idx <= mid:
            self.update(2*pos, l, mid, idx, val)
        else:
            self.update(2*pos+1, mid+1, r, idx, val)
        self.tree[pos] = max(self.tree[2*pos], self.tree[2*pos+1])

    def query(self, pos, l, r, ql, qr):
        if ql > r or qr < l:
            return -float('inf')
        if ql <= l and r <= qr:
            return self.tree[pos]
        mid = (l + r) // 2
        return max(
            self.query(2*pos, l, mid, ql, qr),
            self.query(2*pos+1, mid+1, r, ql, qr)
        )

# Heavy-Light Decomposition
class HLD:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]
        self.parent = [-1]*n
        self.depth = [0]*n
        self.heavy = [-1]*n
        self.head = [0]*n
        self.pos = [0]*n
        self.curr_pos = 0
        self.base_array = [0]*n
        self.segment_tree = SegmentTree(n)
        self.edge_index = {}

    def add_edge(self, u, v, w, idx):
        self.adj[u].append((v, w))
        self.adj[v].append((u, w))
        self.edge_index[(u, v)] = idx
        self.edge_index[(v, u)] = idx

    def dfs(self, u, p):
        size = 1
        max_size = 0
        for v, w in self.adj[u]:
            if v != p:
                self.parent[v] = u
                self.depth[v] = self.depth[u] + 1
                subtree_size = self.dfs(v, u)
                if subtree_size > max_size:
                    max_size = subtree_size
                    self.heavy[u] = v
                size += subtree_size
        return size

    def decompose(self, u, h, weights):
        self.head[u] = h
        self.pos[u] = self.curr_pos
        self.base_array[self.curr_pos] = weights[u]
        self.curr_pos += 1
        if self.heavy[u] != -1:
            self.decompose(self.heavy[u], h, weights)
            for v, w in self.adj[u]:
                if v != self.parent[u] and v != self.heavy[u]:
                    self.decompose(v, v, weights)

    def build(self, weights):
        self.dfs(0, -1)
        self.decompose(0, 0, weights)
        self.segment_tree.build(1, 0, self.n - 1, self.base_array)

    def query(self, u, v):
        res = -float('inf')
        while self.head[u] != self.head[v]:
            if self.depth[self.head[u]] < self.depth[self.head[v]]:
                u, v = v, u
            res = max(res, self.segment_tree.query(1, 0, self.n - 1, self.pos[self.head[u]], self.pos[u]))
            u = self.parent[self.head[u]]
        if u == v:
            return res
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        res = max(res, self.segment_tree.query(1, 0, self.n - 1, self.pos[u]+1, self.pos[v]))
        return res

    def update(self, u, v, w):
        if self.depth[u] < self.depth[v]:
            u, v = v, u
        self.segment_tree.update(1, 0, self.n - 1, self.pos[u], w)


# -----------------------------
# 🌲 Example Tree and Usage
# -----------------------------
#        0
#       / \
#      1   2
#     / \
#    3   4

n = 5
edges = [
    (0, 1, 10),
    (0, 2, 5),
    (1, 3, 4),
    (1, 4, 6),
]

hld = HLD(n)
weights = [0] * n  # node-weight initialization

for idx, (u, v, w) in enumerate(edges):
    hld.add_edge(u, v, w, idx)
    weights[v] = w  # assuming weight is stored at child

hld.build(weights)

print("Max between 3 and 4:", hld.query(3, 4))  # Output: 6
hld.update(1, 4, 15)
print("After update, Max between 3 and 4:", hld.query(3, 4))  # Output: 15
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        curr = self.root
        for ch in word:
            curr = curr.children.setdefault(ch, TrieNode())
        curr.is_word = True

    def search(self, word):
        curr = self.root
        for ch in word:
            if ch not in curr.children:
                return False
            curr = curr.children[ch]
        return curr.is_word

trie = Trie()
trie.insert("apple")
print(trie.search("apple"))  # Output: True
print(trie.search("app"))    # Output: False



